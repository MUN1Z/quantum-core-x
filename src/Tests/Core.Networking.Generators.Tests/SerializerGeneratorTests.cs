using System.Reflection;
using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Extensions.Logging;
using QuantumCore.API.Game.Types;
using QuantumCore.Networking;
using QuantumCore.Networking.Generators;
using Xunit;

namespace Core.Networking.Generators.Tests;

public class SerializerGeneratorTests
{
    private static Compilation CreateCompilation(params string[] source)
        => CSharpCompilation.Create("compilation",
            source.Select(x => CSharpSyntaxTree.ParseText(x)).ToArray(),
            new[]
            {
                MetadataReference.CreateFromFile(typeof(SerializerGeneratorTests).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Binder).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(ClientToServerPacketAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(EPhases).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(ILogger<>).Assembly.Location),
                MetadataReference.CreateFromFile(AppDomain.CurrentDomain.GetAssemblies()
                    .First(x => x.GetName().Name == "System.Runtime").Location),
            },
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));


    [Fact]
    public void Struct_WithSubHeader()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0x32, 0x01)]
public readonly ref partial struct ShopBuy {
    public readonly byte Count;
    public readonly byte Position;
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class ShopBuy : IPacketSerializable
    {
        public static byte Header => 0x32;
        public static byte? SubHeader => 0x01;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x32;
            bytes[offset + 1] = 0x01;
            bytes[offset + 2] = this.Count;
            bytes[offset + 3] = this.Position;
        }

        public ushort GetSize()
        {
            return 4;
        }

        public static ShopBuy Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Count = bytes[(offset + 0)];
            var __Position = bytes[(offset + 1)];
            var obj = new QuantumCore.Core.Packets.ShopBuy
            {
                Count = __Count,
                Position = __Position
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Count = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Position = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var obj = new QuantumCore.Core.Packets.ShopBuy
                {
                    Count = __Count,
                    Position = __Position
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Struct_WithSequence()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0x02, HasSequence = true)]
public readonly ref partial struct Attack
{
    public byte AttackType;
    public uint Vid;
    [FixedSizeArray(2)]
    public byte[] Unknown;
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class Attack : IPacketSerializable
    {
        public static byte Header => 0x02;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => true;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x02;
            bytes[offset + 1] = this.AttackType;
            bytes[offset + 2] = (System.Byte)(this.Vid >> 0);
            bytes[offset + 3] = (System.Byte)(this.Vid >> 8);
            bytes[offset + 4] = (System.Byte)(this.Vid >> 16);
            bytes[offset + 5] = (System.Byte)(this.Vid >> 24);
            this.Unknown.CopyTo(bytes, offset + 6);
            bytes[offset + 8] = default;
        }

        public ushort GetSize()
        {
            return 9;
        }

        public static Attack Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __AttackType = bytes[(offset + 0)];
            var __Vid = System.BitConverter.ToUInt32(bytes[(offset + 1)..(offset + 1 + 4)]);
            var __Unknown = bytes[(offset + 5)..(offset + 7)].ToArray();
            var obj = new QuantumCore.Core.Packets.Attack
            {
                AttackType = __AttackType,
                Vid = __Vid,
                Unknown = __Unknown
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __AttackType = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Vid = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Unknown = await stream.ReadByteArrayFromStreamAsync(buffer, 2);
                var obj = new QuantumCore.Core.Packets.Attack
                {
                    AttackType = __AttackType,
                    Vid = __Vid,
                    Unknown = __Unknown
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Struct_WithDynamicStringAndSequence()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Game.Packets;

[ClientToServerPacket(0x03, HasSequence = true)]
public readonly ref partial struct ChatIncoming
{
    public ushort Size => (ushort)Message.Length;
    public readonly byte MessageType;
    public readonly string Message;
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Game.Packets {

    public partial class ChatIncoming : IPacketSerializable
    {
        public static byte Header => 0x03;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => true;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x03;
            bytes[offset + 1] = (System.Byte)(this.GetSize() >> 0);
            bytes[offset + 2] = (System.Byte)(this.GetSize() >> 8);
            bytes[offset + 3] = this.MessageType;
            bytes.WriteString(this.Message, offset + 4, (int)this.Size + 1);
            bytes[offset + 4 + this.Message.Length] = default;
        }

        public ushort GetSize()
        {
            return (ushort)(5 + this.Message.Length + 1);
        }

        public static ChatIncoming Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Size = System.BitConverter.ToUInt16(bytes[(offset + 0)..(offset + 0 + 2)]) - 4;
            var __MessageType = bytes[(offset + 2)];
            var __Message = (bytes[(offset + 3)..(System.Index)(offset + 3 + __Size)]).ReadNullTerminatedString();
            var obj = new QuantumCore.Game.Packets.ChatIncoming
            {
                MessageType = __MessageType,
                Message = __Message
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Size = await stream.ReadValueFromStreamAsync<UInt16>(buffer) - 4;
                var __MessageType = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Message = await stream.ReadStringFromStreamAsync(buffer, (int)__Size);
                var obj = new QuantumCore.Game.Packets.ChatIncoming
                {
                    MessageType = __MessageType,
                    Message = __Message
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Struct_NoFields()
    {
        var inputCompilation = CreateCompilation(
            """
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [ServerToClientPacket(0x0B)]
            public readonly ref partial struct DeleteCharacterFail
            {
            }
            """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [PacketData(StaticSize = 0)]
            public readonly ref partial struct DeleteCharacterFail
            {
                public static implicit operator byte[] (DeleteCharacterFail packet)
                {
                    var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                    packet.Serialize(bytes);
                    return bytes;
                }
            
                public void Serialize(Span<byte> bytes)
                {
                    bytes[0] = 0x0B;
                }
            
                public ushort GetSize()
                {
                    return 1;
                }
            }

            """);
    }

    [Fact]
    public void SizeAfterArray_Error()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial record struct GCHandshake(byte Type, ushort[] Flags)
{
    public uint Size => Flags.Length;
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out _,
            out var diagnostics);

        driver.GetRunResult();
        diagnostics.Should().HaveCount(1);
        diagnostics[0].GetMessage().Should().BeEquivalentTo("Size fields must be have a position before their array");
    }

    [Fact]
    public void Record_WithDynamic_FieldAfter()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0xff)]
public partial readonly ref struct GCHandshake {
    public uint Size => (uint)this.Message.Length;
    public readonly byte Type;
    public readonly string Message;
    public readonly byte Location;

    public GCHandshake (byte type, string message, byte location)
    {
        Type = type;
        Message = message;
        Location = location;
    }
}
".Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial record struct GCHandshake : IPacketSerializable
    {
        public byte Header => 0xff;
        public byte? SubHeader => null;
        public bool HasStaticSize => false;
        public bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = this.Type;
            bytes[offset + 2] = (System.Byte)(this.GetSize() >> 0);
            bytes[offset + 3] = (System.Byte)(this.GetSize() >> 8);
            bytes[offset + 4] = (System.Byte)(this.GetSize() >> 16);
            bytes[offset + 5] = (System.Byte)(this.GetSize() >> 24);
            bytes.WriteString(this.Message, offset + 6, (int)this.Size + 1);
            bytes[offset + 6 + this.Message.Length] = this.Location;
        }

        public ushort GetSize()
        {
            return (ushort)(7 + this.Message.Length + 1);
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Type = bytes[(offset + 0)];
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 1)..(offset + 1 + 4)]) - 7;
            var __Message = (bytes[(offset + 5)..(System.Index)(offset + 5 + __Size)]).ReadNullTerminatedString();
            var __Location = bytes[(System.Index)(offset + 5 + __Size)];
            var obj = new QuantumCore.Core.Packets.GCHandshake
            (
                __Type,
                __Message,
                __Location
            );
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Type = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 7;
                var __Message = await stream.ReadStringFromStreamAsync(buffer, (int)__Size);
                var __Location = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                (
                    __Type,
                    __Message,
                    __Location
                );
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void MultipleTypesPerFile()
    {
        var inputCompilation = CreateCompilation("""

                                                 using QuantumCore.Networking;

                                                 namespace QuantumCore.Core.Packets;

                                                 [ServerToClientPacket(0xff)]
                                                 public readonly ref partial struct GCHandshake
                                                 {
                                                     public readonly uint Handshake;
                                                     public readonly uint Time;
                                                     public readonly uint Delta;
                                                 }

                                                 [ServerToClientPacket(0xfd)]
                                                 public readonly ref partial struct GCPhase
                                                 {
                                                     public readonly byte Phase;
                                                 }

                                                 """.Trim());

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(2);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(2);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources.First(x => x.SourceText.ToString().Contains("GCHandshake"))
            .SourceText.ToString().Should().BeEquivalentTo("""
                                                           /// <auto-generated/>
                                                           using System;
                                                           using System.Buffers;
                                                           using QuantumCore.Networking;

                                                           namespace QuantumCore.Core.Packets;

                                                           [PacketData(StaticSize = 12)]
                                                           public readonly ref partial struct GCHandshake
                                                           {
                                                               public static implicit operator byte[] (GCHandshake packet)
                                                               {
                                                                   var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                                                                   packet.Serialize(bytes);
                                                                   return bytes;
                                                               }
                                                           
                                                               public void Serialize(Span<byte> bytes)
                                                               {
                                                                   bytes[0] = 0xFF;
                                                                   bytes[1] = (System.Byte)(this.Handshake >> 0);
                                                                   bytes[2] = (System.Byte)(this.Handshake >> 8);
                                                                   bytes[3] = (System.Byte)(this.Handshake >> 16);
                                                                   bytes[4] = (System.Byte)(this.Handshake >> 24);
                                                                   bytes[5] = (System.Byte)(this.Time >> 0);
                                                                   bytes[6] = (System.Byte)(this.Time >> 8);
                                                                   bytes[7] = (System.Byte)(this.Time >> 16);
                                                                   bytes[8] = (System.Byte)(this.Time >> 24);
                                                                   bytes[9] = (System.Byte)(this.Delta >> 0);
                                                                   bytes[10] = (System.Byte)(this.Delta >> 8);
                                                                   bytes[11] = (System.Byte)(this.Delta >> 16);
                                                                   bytes[12] = (System.Byte)(this.Delta >> 24);
                                                               }
                                                           
                                                               public ushort GetSize()
                                                               {
                                                                   return 13;
                                                               }
                                                           }

                                                           """);
        runResult.Results[0].GeneratedSources.First(x => x.SourceText.ToString().Contains("GCPhase"))
            .SourceText.ToString().Should().BeEquivalentTo("""
                                                           /// <auto-generated/>
                                                           using System;
                                                           using System.Buffers;
                                                           using QuantumCore.Networking;

                                                           namespace QuantumCore.Core.Packets;

                                                           [PacketData(StaticSize = 1)]
                                                           public readonly ref partial struct GCPhase
                                                           {
                                                               public static implicit operator byte[] (GCPhase packet)
                                                               {
                                                                   var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                                                                   packet.Serialize(bytes);
                                                                   return bytes;
                                                               }
                                                           
                                                               public void Serialize(Span<byte> bytes)
                                                               {
                                                                   bytes[0] = 0xFD;
                                                                   bytes[1] = this.Phase;
                                                               }
                                                           
                                                               public ushort GetSize()
                                                               {
                                                                   return 2;
                                                               }
                                                           }

                                                           """);
    }

    [Fact]
    public void Struct_ClientToServer()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0xff)]
public readonly ref partial struct GCHandshake {
    public readonly uint Handshake;
    public readonly uint Time;
    public readonly uint Delta;
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].HintName.Should().BeEquivalentTo("GCHandshake.ClientToServer.g.cs");
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [PacketData(StaticSize = 12)]
            public readonly ref partial struct GCHandshake
            {
                public GCHandshake(ReadOnlySpan<byte> bytes)
                {
                    Handshake = System.BitConverter.ToUInt32(bytes[0..(System.Index)(0 + 4)]);
                    Time = System.BitConverter.ToUInt32(bytes[4..(System.Index)(4 + 4)]);
                    Delta = System.BitConverter.ToUInt32(bytes[8..(System.Index)(8 + 4)]);
                }
            }

            """);
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial struct GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (System.Byte)(this.Handshake >> 0);
            bytes[offset + 2] = (System.Byte)(this.Handshake >> 8);
            bytes[offset + 3] = (System.Byte)(this.Handshake >> 16);
            bytes[offset + 4] = (System.Byte)(this.Handshake >> 24);
            bytes[offset + 5] = (System.Byte)(this.Time >> 0);
            bytes[offset + 6] = (System.Byte)(this.Time >> 8);
            bytes[offset + 7] = (System.Byte)(this.Time >> 16);
            bytes[offset + 8] = (System.Byte)(this.Time >> 24);
            bytes[offset + 9] = (System.Byte)(this.Delta >> 0);
            bytes[offset + 10] = (System.Byte)(this.Delta >> 8);
            bytes[offset + 11] = (System.Byte)(this.Delta >> 16);
            bytes[offset + 12] = (System.Byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return 13;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Delta = __Delta
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Delta = __Delta
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Struct_ServerToClient()
    {
        var inputCompilation = CreateCompilation("""

                                                 using QuantumCore.Networking;

                                                 namespace QuantumCore.Core.Packets;

                                                 [ServerToClientPacket(0xff)]
                                                 public readonly ref partial struct GCHandshake {
                                                 public readonly uint Handshake;
                                                 public readonly uint Time;
                                                 public readonly uint Delta;
                                                 [Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
                                                 [PacketGenerator]
                                                 public partial class GCHandshake {
                                                     public uint Handshake { get; set; }
                                                     public uint Time { get; set; }
                                                     public uint Delta { get; set; }
                                                 }
                                                 """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using System.IO;
            using System.Threading.Tasks;
            using QuantumCore.Networking;

            // no async warning if no properties
            #pragma warning disable CS1998

            namespace QuantumCore.Core.Packets {
            
                public partial class GCHandshake : IPacketSerializable
                {
                    public byte Header => 0xff;
                    public byte? SubHeader => null;
                    public bool HasStaticSize => true;
                    public bool HasSequence => false;
            
                    public void Serialize(byte[] bytes, in int offset = 0)
                    {
                        bytes[offset + 0] = 0xff;
                        bytes[offset + 1] = (System.Byte)(this.Handshake >> 0);
                        bytes[offset + 2] = (System.Byte)(this.Handshake >> 8);
                        bytes[offset + 3] = (System.Byte)(this.Handshake >> 16);
                        bytes[offset + 4] = (System.Byte)(this.Handshake >> 24);
                        bytes[offset + 5] = (System.Byte)(this.Time >> 0);
                        bytes[offset + 6] = (System.Byte)(this.Time >> 8);
                        bytes[offset + 7] = (System.Byte)(this.Time >> 16);
                        bytes[offset + 8] = (System.Byte)(this.Time >> 24);
                        bytes[offset + 9] = (System.Byte)(this.Delta >> 0);
                        bytes[offset + 10] = (System.Byte)(this.Delta >> 8);
                        bytes[offset + 11] = (System.Byte)(this.Delta >> 16);
                        bytes[offset + 12] = (System.Byte)(this.Delta >> 24);
                    }
            
                    public ushort GetSize()
                    {
                        return 13;
                    }
            
                    public void Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
                    {
                        Handshake = System.BitConverter.ToUInt32(bytes[(System.Index)(offset + 0)..(System.Index)(offset + 0 + 4)]);
                        Time = System.BitConverter.ToUInt32(bytes[(System.Index)(offset + 4)..(System.Index)(offset + 4 + 4)]);
                        Delta = System.BitConverter.ToUInt32(bytes[(System.Index)(offset + 8)..(System.Index)(offset + 8 + 4)]);
                    }
            
                    public async ValueTask DeserializeFromStreamAsync(Stream stream)
                    {
                        var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
                        try
                        {
                            Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                        }
                        catch (Exception)
                        {
                            throw;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }
                }
            }
            """);
    }

    [Fact]
    public void Class_WithBool()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming)]
[PacketGenerator]
public partial class Squidward {
    public bool IsHandsome { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].HintName.Should().BeEquivalentTo("GCHandshake.ServerToClient.g.cs");
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [PacketData(StaticSize = 12)]
            public readonly ref partial struct GCHandshake
            {
                public static implicit operator byte[] (GCHandshake packet)
                {
                    var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                    packet.Serialize(bytes);
                    return bytes;
                }
            
                public void Serialize(Span<byte> bytes)
                {
                    bytes[0] = 0xFF;
                    bytes[1] = (System.Byte)(this.Handshake >> 0);
                    bytes[2] = (System.Byte)(this.Handshake >> 8);
                    bytes[3] = (System.Byte)(this.Handshake >> 16);
                    bytes[4] = (System.Byte)(this.Handshake >> 24);
                    bytes[5] = (System.Byte)(this.Time >> 0);
                    bytes[6] = (System.Byte)(this.Time >> 8);
                    bytes[7] = (System.Byte)(this.Time >> 16);
                    bytes[8] = (System.Byte)(this.Time >> 24);
                    bytes[9] = (System.Byte)(this.Delta >> 0);
                    bytes[10] = (System.Byte)(this.Delta >> 8);
                    bytes[11] = (System.Byte)(this.Delta >> 16);
                    bytes[12] = (System.Byte)(this.Delta >> 24);
                }
            
                public ushort GetSize()
                {
                    return 13;
                }
            }

            """);
    }

    [Fact]
    public void Class_ClientToServer()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0xff)]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [PacketData(StaticSize = 12)]
            public partial class GCHandshake
            {
                public GCHandshake()
                {
                }
            
                public GCHandshake(ReadOnlySpan<byte> bytes)
                {
                    Handshake = System.BitConverter.ToUInt32(bytes[0..(0 + 4)]);
                    Time = System.BitConverter.ToUInt32(bytes[4..(4 + 4)]);
                    Delta = System.BitConverter.ToUInt32(bytes[8..(8 + 4)]);
                }
            }

            """);
    }

    [Fact]
    public void Class_FixedSizeString()
    {
        var inputCompilation = CreateCompilation(
            """

            using QuantumCore.Networking;

            namespace QuantumCore.Auth.Packets;

            [ServerToClientPacket(0x07)]
            public partial class LoginFailed
            {
                [FixedSizeString(9)]public string Status { get; set; } = "";
            }

            """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using QuantumCore.Networking;

            namespace QuantumCore.Auth.Packets;

            [PacketData(StaticSize = 9)]
            public partial class LoginFailed
            {
                public static implicit operator byte[] (LoginFailed packet)
                {
                    var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                    packet.Serialize(bytes);
                    return bytes;
                }
            
                public void Serialize(Span<byte> bytes)
                {
                    bytes[0] = 0x07;
                    bytes[1..(1 + 9)].WriteString(this.Status);
                }
            
                public ushort GetSize()
                {
                    return 10;
                }
            }

            """);
    }

    [Fact]
    public void Class_WithEnumProperty()
    {
        var inputCompilation = CreateCompilation(
            """
            using QuantumCore.API.Game.Types;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [ServerToClientPacket(0xfd)]
            public partial class GCPhase
            {
                public EPhases Phase { get; set; }
            }
            """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [PacketData(StaticSize = 1)]
            public partial class GCPhase
            {
                public static implicit operator byte[] (GCPhase packet)
                {
                    var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                    packet.Serialize(bytes);
                    return bytes;
                }
            
                public void Serialize(Span<byte> bytes)
                {
                    bytes[0] = 0xFD;
                    bytes[1] = (System.Byte)this.Phase;
                }
            
                public ushort GetSize()
                {
                    return 2;
                }
            }

            """);
    }


    [Fact]
    public void Class_ServerToClient()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ServerToClientPacket(0xff)]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [PacketData(StaticSize = 12)]
            public partial class GCHandshake
            {
                public static implicit operator byte[] (GCHandshake packet)
                {
                    var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                    packet.Serialize(bytes);
                    return bytes;
                }
            
                public void Serialize(Span<byte> bytes)
                {
                    bytes[0] = 0xFF;
                    bytes[1] = (System.Byte)(this.Handshake >> 0);
                    bytes[2] = (System.Byte)(this.Handshake >> 8);
                    bytes[3] = (System.Byte)(this.Handshake >> 16);
                    bytes[4] = (System.Byte)(this.Handshake >> 24);
                    bytes[5] = (System.Byte)(this.Time >> 0);
                    bytes[6] = (System.Byte)(this.Time >> 8);
                    bytes[7] = (System.Byte)(this.Time >> 16);
                    bytes[8] = (System.Byte)(this.Time >> 24);
                    bytes[9] = (System.Byte)(this.Delta >> 0);
                    bytes[10] = (System.Byte)(this.Delta >> 8);
                    bytes[11] = (System.Byte)(this.Delta >> 16);
                    bytes[12] = (System.Byte)(this.Delta >> 24);
                }
            
                public ushort GetSize()
                {
                    return 13;
                }
            }

            """);
    }

    [Fact]
    public void Record()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0xff)]
public partial record GCHandshake(uint Handshake, uint Time, uint Delta);");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using System.IO;
            using System.Threading.Tasks;
            using QuantumCore.Networking;

            // no async warning if no properties
            #pragma warning disable CS1998

            namespace QuantumCore.Core.Packets {
            
                public partial class GCHandshake : IPacketSerializable
                {
                    public static byte Header => 0xff;
                    public static byte? SubHeader => null;
                    public static bool HasStaticSize => true;
                    public static bool HasSequence => false;
            
                    public void Serialize(byte[] bytes, in int offset = 0)
                    {
                        bytes[offset + 0] = 0xff;
                        bytes[offset + 1] = (System.Byte)(this.Handshake >> 0);
                        bytes[offset + 2] = (System.Byte)(this.Handshake >> 8);
                        bytes[offset + 3] = (System.Byte)(this.Handshake >> 16);
                        bytes[offset + 4] = (System.Byte)(this.Handshake >> 24);
                        bytes[offset + 5] = (System.Byte)(this.Time >> 0);
                        bytes[offset + 6] = (System.Byte)(this.Time >> 8);
                        bytes[offset + 7] = (System.Byte)(this.Time >> 16);
                        bytes[offset + 8] = (System.Byte)(this.Time >> 24);
                        bytes[offset + 9] = (System.Byte)(this.Delta >> 0);
                        bytes[offset + 10] = (System.Byte)(this.Delta >> 8);
                        bytes[offset + 11] = (System.Byte)(this.Delta >> 16);
                        bytes[offset + 12] = (System.Byte)(this.Delta >> 24);
                        bytes[offset + 13] = (System.Byte)(this.Sub.SomeSubData >> 0);
                        bytes[offset + 14] = (System.Byte)(this.Sub.SomeSubData >> 8);
                        bytes[offset + 15] = (System.Byte)(this.Sub.SomeSubData >> 16);
                        bytes[offset + 16] = (System.Byte)(this.Sub.SomeSubData >> 24);
                    }
            
                    public ushort GetSize()
                    {
                        return 17;
                    }
            
                    public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
                    {
                        var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
                        var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
                        var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
                        var __Sub = new QuantumCore.Core.Packets.SomeData
                        {
                            SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12)..(offset + 12 + 4)])
                        };
                        var obj = new QuantumCore.Core.Packets.GCHandshake
                        {
                            Handshake = __Handshake,
                            Time = __Time,
                            Delta = __Delta,
                            Sub = __Sub
                        };
                        return obj;
                    }
            
                    public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
                        where T : IPacketSerializable
                    {
                        return (T)(object)Deserialize(bytes, offset);
                    }
            
                    public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
                    {
                        var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
                        try
                        {
                            var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Sub = new QuantumCore.Core.Packets.SomeData
                            {
                                SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                            };
                            var obj = new QuantumCore.Core.Packets.GCHandshake
                            {
                                Handshake = __Handshake,
                                Time = __Time,
                                Delta = __Delta,
                                Sub = __Sub
                            };
                            return obj;
                        }
                        catch (Exception)
                        {
                            throw;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }
                }
            }
            """);
    }

    [Fact]
    public void Struct_WithSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0xff)]
public readonly ref partial struct GCHandshake
{
    public readonly uint Handshake;
    public readonly uint Time;
    public readonly uint Delta;
    public readonly SomeData Sub;
}

public readonly ref struct SomeData {
    public readonly uint SomeSubData;
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using System.IO;
            using System.Threading.Tasks;
            using QuantumCore.Networking;

            // no async warning if no properties
            #pragma warning disable CS1998

            namespace QuantumCore.Core.Packets {
            
                public partial class GCHandshake : IPacketSerializable
                {
                    public static byte Header => 0xff;
                    public static byte? SubHeader => null;
                    public static bool HasStaticSize => true;
                    public static bool HasSequence => false;
            
                    public void Serialize(byte[] bytes, in int offset = 0)
                    {
                        bytes[offset + 0] = 0xff;
                        bytes[offset + 1] = (System.Byte)(this.Handshake >> 0);
                        bytes[offset + 2] = (System.Byte)(this.Handshake >> 8);
                        bytes[offset + 3] = (System.Byte)(this.Handshake >> 16);
                        bytes[offset + 4] = (System.Byte)(this.Handshake >> 24);
                        bytes[offset + 5] = (System.Byte)(this.Time >> 0);
                        bytes[offset + 6] = (System.Byte)(this.Time >> 8);
                        bytes[offset + 7] = (System.Byte)(this.Time >> 16);
                        bytes[offset + 8] = (System.Byte)(this.Time >> 24);
                        bytes[offset + 9] = (System.Byte)(this.Delta >> 0);
                        bytes[offset + 10] = (System.Byte)(this.Delta >> 8);
                        bytes[offset + 11] = (System.Byte)(this.Delta >> 16);
                        bytes[offset + 12] = (System.Byte)(this.Delta >> 24);
                        bytes[offset + 13] = (System.Byte)(this.Sub.SomeSubData >> 0);
                        bytes[offset + 14] = (System.Byte)(this.Sub.SomeSubData >> 8);
                        bytes[offset + 15] = (System.Byte)(this.Sub.SomeSubData >> 16);
                        bytes[offset + 16] = (System.Byte)(this.Sub.SomeSubData >> 24);
                    }
            
                    public ushort GetSize()
                    {
                        return 17;
                    }
            
                    public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
                    {
                        var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
                        var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
                        var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
                        var __Sub = new QuantumCore.Core.Packets.SomeData
                        {
                            SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12)..(offset + 12 + 4)])
                        };
                        var obj = new QuantumCore.Core.Packets.GCHandshake
                        {
                            Handshake = __Handshake,
                            Time = __Time,
                            Delta = __Delta,
                            Sub = __Sub
                        };
                        return obj;
                    }
            
                    public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
                        where T : IPacketSerializable
                    {
                        return (T)(object)Deserialize(bytes, offset);
                    }
            
                    public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
                    {
                        var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
                        try
                        {
                            var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Sub = new QuantumCore.Core.Packets.SomeData
                            {
                                SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                            };
                            var obj = new QuantumCore.Core.Packets.GCHandshake
                            {
                                Handshake = __Handshake,
                                Time = __Time,
                                Delta = __Delta,
                                Sub = __Sub
                            };
                            return obj;
                        }
                        catch (Exception)
                        {
                            throw;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }
                }
            }
            """);
    }

    [Fact]
    public void Struct_WithFixedArrayOfSubClass()
    {
        var inputCompilation = CreateCompilation("""

                                                 using QuantumCore.Networking;

                                                 namespace QuantumCore.Core.Packets;

                                                 [ClientToServerPacket(0xff)]
                                                 public readonly ref partial struct GCHandshake
                                                 {
                                                     public readonly uint Handshake;
                                                     public readonly uint Time;
                                                     public readonly uint Delta;
                                                     [FixedSizeArray(4)]
                                                     public readonly SomeData[] Subs;
                                                 }

                                                 public readonly struct SomeData {
                                                     public readonly uint SomeSubData;
                                                     public readonly uint SomeSubData2;
                                                 }
                                                 """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using System.IO;
            using System.Threading.Tasks;
            using QuantumCore.Networking;

            // no async warning if no properties
            #pragma warning disable CS1998

            namespace QuantumCore.Core.Packets {
            
                public partial class GCHandshake : IPacketSerializable
                {
                    public static byte Header => 0xff;
                    public static byte? SubHeader => null;
                    public static bool HasStaticSize => true;
                    public static bool HasSequence => false;
            
                    public void Serialize(byte[] bytes, in int offset = 0)
                    {
                        bytes[offset + 0] = 0xff;
                        bytes[offset + 1] = (byte)(this.Handshake >> 0);
                        bytes[offset + 2] = (byte)(this.Handshake >> 8);
                        bytes[offset + 3] = (byte)(this.Handshake >> 16);
                        bytes[offset + 4] = (byte)(this.Handshake >> 24);
                        bytes[offset + 5] = (byte)(this.Time >> 0);
                        bytes[offset + 6] = (byte)(this.Time >> 8);
                        bytes[offset + 7] = (byte)(this.Time >> 16);
                        bytes[offset + 8] = (byte)(this.Time >> 24);
                        bytes[offset + 9] = (byte)(this.Delta >> 0);
                        bytes[offset + 10] = (byte)(this.Delta >> 8);
                        bytes[offset + 11] = (byte)(this.Delta >> 16);
                        bytes[offset + 12] = (byte)(this.Delta >> 24);
                        bytes[offset + 13] = (byte)(this.Subs[0].SomeSubData >> 0);
                        bytes[offset + 14] = (byte)(this.Subs[0].SomeSubData >> 8);
                        bytes[offset + 15] = (byte)(this.Subs[0].SomeSubData >> 16);
                        bytes[offset + 16] = (byte)(this.Subs[0].SomeSubData >> 24);
                        bytes[offset + 17] = (byte)(this.Subs[0].SomeSubData2 >> 0);
                        bytes[offset + 18] = (byte)(this.Subs[0].SomeSubData2 >> 8);
                        bytes[offset + 19] = (byte)(this.Subs[0].SomeSubData2 >> 16);
                        bytes[offset + 20] = (byte)(this.Subs[0].SomeSubData2 >> 24);
                        bytes[offset + 21] = (byte)(this.Subs[1].SomeSubData >> 0);
                        bytes[offset + 22] = (byte)(this.Subs[1].SomeSubData >> 8);
                        bytes[offset + 23] = (byte)(this.Subs[1].SomeSubData >> 16);
                        bytes[offset + 24] = (byte)(this.Subs[1].SomeSubData >> 24);
                        bytes[offset + 25] = (byte)(this.Subs[1].SomeSubData2 >> 0);
                        bytes[offset + 26] = (byte)(this.Subs[1].SomeSubData2 >> 8);
                        bytes[offset + 27] = (byte)(this.Subs[1].SomeSubData2 >> 16);
                        bytes[offset + 28] = (byte)(this.Subs[1].SomeSubData2 >> 24);
                        bytes[offset + 29] = (byte)(this.Subs[2].SomeSubData >> 0);
                        bytes[offset + 30] = (byte)(this.Subs[2].SomeSubData >> 8);
                        bytes[offset + 31] = (byte)(this.Subs[2].SomeSubData >> 16);
                        bytes[offset + 32] = (byte)(this.Subs[2].SomeSubData >> 24);
                        bytes[offset + 33] = (byte)(this.Subs[2].SomeSubData2 >> 0);
                        bytes[offset + 34] = (byte)(this.Subs[2].SomeSubData2 >> 8);
                        bytes[offset + 35] = (byte)(this.Subs[2].SomeSubData2 >> 16);
                        bytes[offset + 36] = (byte)(this.Subs[2].SomeSubData2 >> 24);
                        bytes[offset + 37] = (byte)(this.Subs[3].SomeSubData >> 0);
                        bytes[offset + 38] = (byte)(this.Subs[3].SomeSubData >> 8);
                        bytes[offset + 39] = (byte)(this.Subs[3].SomeSubData >> 16);
                        bytes[offset + 40] = (byte)(this.Subs[3].SomeSubData >> 24);
                        bytes[offset + 41] = (byte)(this.Subs[3].SomeSubData2 >> 0);
                        bytes[offset + 42] = (byte)(this.Subs[3].SomeSubData2 >> 8);
                        bytes[offset + 43] = (byte)(this.Subs[3].SomeSubData2 >> 16);
                        bytes[offset + 44] = (byte)(this.Subs[3].SomeSubData2 >> 24);
                    }
            
                    public ushort GetSize()
                    {
                        return 45;
                    }
            
                    public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
                    {
                        var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
                        var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
                        var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
                        var __Subs = new []
                        {
                            new QuantumCore.Core.Packets.SomeData
                            {
                                SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12)..(offset + 12 + 4)]),
                                SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 16)..(offset + 16 + 4)])
                            },
                            new QuantumCore.Core.Packets.SomeData
                            {
                                SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 20)..(offset + 20 + 4)]),
                                SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 24)..(offset + 24 + 4)])
                            },
                            new QuantumCore.Core.Packets.SomeData
                            {
                                SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 28)..(offset + 28 + 4)]),
                                SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 32)..(offset + 32 + 4)])
                            },
                            new QuantumCore.Core.Packets.SomeData
                            {
                                SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 36)..(offset + 36 + 4)]),
                                SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 40)..(offset + 40 + 4)])
                            }
                        };
                        var obj = new QuantumCore.Core.Packets.GCHandshake
                        {
                            Handshake = __Handshake,
                            Time = __Time,
                            Delta = __Delta,
                            Subs = __Subs
                        };
                        return obj;
                    }
            
                    public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
                        where T : IPacketSerializable
                    {
                        return (T)(object)Deserialize(bytes, offset);
                    }
            
                    public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
                    {
                        var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
                        try
                        {
                            var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Subs = new []
                            {
                                new QuantumCore.Core.Packets.SomeData
                                {
                                    SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                                    SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                                },
                                new QuantumCore.Core.Packets.SomeData
                                {
                                    SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                                    SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                                },
                                new QuantumCore.Core.Packets.SomeData
                                {
                                    SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                                    SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                                },
                                new QuantumCore.Core.Packets.SomeData
                                {
                                    SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                                    SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                                }
                            };
                            var obj = new QuantumCore.Core.Packets.GCHandshake
                            {
                                Handshake = __Handshake,
                                Time = __Time,
                                Delta = __Delta,
                                Subs = __Subs
                            };
                            return obj;
                        }
                        catch (Exception)
                        {
                            throw;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }
                }
            }
            """);
    }

    [Fact]
    public void Class_WithFixedArrayOfSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[Packet(0xff, EDirection.Incoming | EDirection.Outgoing)]
[PacketGenerator]
public partial class GCHandshake {
    public uint Handshake { get; set; }
    public uint Time { get; set; }
    public uint Delta { get; set; }
    public SomeData[] Subs { get; set; } = new SomeData[4];
}

public class SomeData {
    public uint SomeSubData { get; set; }
    public uint SomeSubData2 { get; set; }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (System.Byte)(this.Handshake >> 0);
            bytes[offset + 2] = (System.Byte)(this.Handshake >> 8);
            bytes[offset + 3] = (System.Byte)(this.Handshake >> 16);
            bytes[offset + 4] = (System.Byte)(this.Handshake >> 24);
            bytes[offset + 5] = (System.Byte)(this.Time >> 0);
            bytes[offset + 6] = (System.Byte)(this.Time >> 8);
            bytes[offset + 7] = (System.Byte)(this.Time >> 16);
            bytes[offset + 8] = (System.Byte)(this.Time >> 24);
            bytes[offset + 9] = (System.Byte)(this.Delta >> 0);
            bytes[offset + 10] = (System.Byte)(this.Delta >> 8);
            bytes[offset + 11] = (System.Byte)(this.Delta >> 16);
            bytes[offset + 12] = (System.Byte)(this.Delta >> 24);
            bytes[offset + 13] = (System.Byte)(this.Subs[0].SomeSubData >> 0);
            bytes[offset + 14] = (System.Byte)(this.Subs[0].SomeSubData >> 8);
            bytes[offset + 15] = (System.Byte)(this.Subs[0].SomeSubData >> 16);
            bytes[offset + 16] = (System.Byte)(this.Subs[0].SomeSubData >> 24);
            bytes[offset + 17] = (System.Byte)(this.Subs[0].SomeSubData2 >> 0);
            bytes[offset + 18] = (System.Byte)(this.Subs[0].SomeSubData2 >> 8);
            bytes[offset + 19] = (System.Byte)(this.Subs[0].SomeSubData2 >> 16);
            bytes[offset + 20] = (System.Byte)(this.Subs[0].SomeSubData2 >> 24);
            bytes[offset + 21] = (System.Byte)(this.Subs[1].SomeSubData >> 0);
            bytes[offset + 22] = (System.Byte)(this.Subs[1].SomeSubData >> 8);
            bytes[offset + 23] = (System.Byte)(this.Subs[1].SomeSubData >> 16);
            bytes[offset + 24] = (System.Byte)(this.Subs[1].SomeSubData >> 24);
            bytes[offset + 25] = (System.Byte)(this.Subs[1].SomeSubData2 >> 0);
            bytes[offset + 26] = (System.Byte)(this.Subs[1].SomeSubData2 >> 8);
            bytes[offset + 27] = (System.Byte)(this.Subs[1].SomeSubData2 >> 16);
            bytes[offset + 28] = (System.Byte)(this.Subs[1].SomeSubData2 >> 24);
            bytes[offset + 29] = (System.Byte)(this.Subs[2].SomeSubData >> 0);
            bytes[offset + 30] = (System.Byte)(this.Subs[2].SomeSubData >> 8);
            bytes[offset + 31] = (System.Byte)(this.Subs[2].SomeSubData >> 16);
            bytes[offset + 32] = (System.Byte)(this.Subs[2].SomeSubData >> 24);
            bytes[offset + 33] = (System.Byte)(this.Subs[2].SomeSubData2 >> 0);
            bytes[offset + 34] = (System.Byte)(this.Subs[2].SomeSubData2 >> 8);
            bytes[offset + 35] = (System.Byte)(this.Subs[2].SomeSubData2 >> 16);
            bytes[offset + 36] = (System.Byte)(this.Subs[2].SomeSubData2 >> 24);
            bytes[offset + 37] = (System.Byte)(this.Subs[3].SomeSubData >> 0);
            bytes[offset + 38] = (System.Byte)(this.Subs[3].SomeSubData >> 8);
            bytes[offset + 39] = (System.Byte)(this.Subs[3].SomeSubData >> 16);
            bytes[offset + 40] = (System.Byte)(this.Subs[3].SomeSubData >> 24);
            bytes[offset + 41] = (System.Byte)(this.Subs[3].SomeSubData2 >> 0);
            bytes[offset + 42] = (System.Byte)(this.Subs[3].SomeSubData2 >> 8);
            bytes[offset + 43] = (System.Byte)(this.Subs[3].SomeSubData2 >> 16);
            bytes[offset + 44] = (System.Byte)(this.Subs[3].SomeSubData2 >> 24);
        }

        public ushort GetSize()
        {
            return 45;
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Delta = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]);
            var __Subs = new []
            {
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12)..(offset + 12 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 16)..(offset + 16 + 4)])
                },
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 20)..(offset + 20 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 24)..(offset + 24 + 4)])
                },
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 28)..(offset + 28 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 32)..(offset + 32 + 4)])
                },
                new QuantumCore.Core.Packets.SomeData
                {
                    SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 36)..(offset + 36 + 4)]),
                    SomeSubData2 = System.BitConverter.ToUInt32(bytes[(offset + 40)..(offset + 40 + 4)])
                }
            };
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Delta = __Delta,
                Subs = __Subs
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Subs = new []
                {
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    },
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    },
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    },
                    new QuantumCore.Core.Packets.SomeData
                    {
                        SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer),
                        SomeSubData2 = await stream.ReadValueFromStreamAsync<UInt32>(buffer)
                    }
                };
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Delta = __Delta,
                    Subs = __Subs
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Struct_WithDynamicArrayOfSubClass()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0xff)]
public readonly ref partial struct GCHandshake {
    public readonly uint Handshake;
    public readonly uint Time;
    public readonly uint Size => (uint)Subs.Length;
    public readonly SomeData[] Subs;
    public readonly uint Delta;
}

public readonly ref struct SomeData {
    public readonly uint SomeSubData;
    public readonly byte SubByte;
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Core.Packets {

    public partial class GCHandshake : IPacketSerializable
    {
        public static byte Header => 0xff;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => false;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0xff;
            bytes[offset + 1] = (System.Byte)(this.Handshake >> 0);
            bytes[offset + 2] = (System.Byte)(this.Handshake >> 8);
            bytes[offset + 3] = (System.Byte)(this.Handshake >> 16);
            bytes[offset + 4] = (System.Byte)(this.Handshake >> 24);
            bytes[offset + 5] = (System.Byte)(this.Time >> 0);
            bytes[offset + 6] = (System.Byte)(this.Time >> 8);
            bytes[offset + 7] = (System.Byte)(this.Time >> 16);
            bytes[offset + 8] = (System.Byte)(this.Time >> 24);
            bytes[offset + 9] = (System.Byte)(this.GetSize() >> 0);
            bytes[offset + 10] = (System.Byte)(this.GetSize() >> 8);
            bytes[offset + 11] = (System.Byte)(this.GetSize() >> 16);
            bytes[offset + 12] = (System.Byte)(this.GetSize() >> 24);
            for (var i = 0; i < this.Subs.Length; i++)
            {
                bytes[offset + 13 + i * 5] = (System.Byte)(this.Subs[i].SomeSubData >> 0);
                bytes[offset + 14 + i * 5] = (System.Byte)(this.Subs[i].SomeSubData >> 8);
                bytes[offset + 15 + i * 5] = (System.Byte)(this.Subs[i].SomeSubData >> 16);
                bytes[offset + 16 + i * 5] = (System.Byte)(this.Subs[i].SomeSubData >> 24);
                bytes[offset + 17 + i * 5] = this.Subs[i].SubByte;
            }
            bytes[offset + 13 + this.Subs.Length * 5] = (System.Byte)(this.Delta >> 0);
            bytes[offset + 14 + this.Subs.Length * 5] = (System.Byte)(this.Delta >> 8);
            bytes[offset + 15 + this.Subs.Length * 5] = (System.Byte)(this.Delta >> 16);
            bytes[offset + 16 + this.Subs.Length * 5] = (System.Byte)(this.Delta >> 24);
        }

        public ushort GetSize()
        {
            return (ushort)(17 + this.Subs.Length * 5);
        }

        public static GCHandshake Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Handshake = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
            var __Time = System.BitConverter.ToUInt32(bytes[(offset + 4)..(offset + 4 + 4)]);
            var __Size = System.BitConverter.ToUInt32(bytes[(offset + 8)..(offset + 8 + 4)]) - 22;
            var __Subs = new QuantumCore.Core.Packets.SomeData[__Size];
            for (var i = 0; i < __Size; i++)
            {
                __Subs[i].SomeSubData = System.BitConverter.ToUInt32(bytes[(offset + 12 + 5 * i)..(offset + 12 + 5 * i + 4)]);
                __Subs[i].SubByte = bytes[(offset + 16 + 5 * i)];
            }
            var __Delta = System.BitConverter.ToUInt32(bytes[(System.Index)(offset + 17 + __Size)..(System.Index)(offset + 17 + __Size + 4)]);
            var obj = new QuantumCore.Core.Packets.GCHandshake
            {
                Handshake = __Handshake,
                Time = __Time,
                Subs = __Subs,
                Delta = __Delta
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Handshake = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Time = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 22;
                var __Subs = new QuantumCore.Core.Packets.SomeData[__Size];
                for (var i = 0; i < __Size; i++)
                {
                    __Subs[i].SomeSubData = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                    __Subs[i].SubByte = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                }
                var __Delta = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                var obj = new QuantumCore.Core.Packets.GCHandshake
                {
                    Handshake = __Handshake,
                    Time = __Time,
                    Subs = __Subs,
                    Delta = __Delta
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Struct_DataAfterFixedUshortArray()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Core.Packets;

[ClientToServerPacket(0x88)]
public readonly ref partial struct CharacterInfo
{
    public readonly uint Vid;
    [FixedSizeString(25)] public readonly string Name;
    [FixedSizeArray(4)] public readonly ushort[] Parts;
    public readonly byte Empire;
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using QuantumCore.Networking;

            namespace QuantumCore.Core.Packets;

            [PacketData(StaticSize = 38)]
            public readonly ref partial struct CharacterInfo
            {
                public CharacterInfo(ReadOnlySpan<byte> bytes)
                {
                    Vid = System.BitConverter.ToUInt32(bytes[0..(System.Index)(0 + 4)]);
                    Name = bytes[4..(System.Index)(4 + 25)].ReadNullTerminatedString();
                    Parts = new []
                    {
                        System.BitConverter.ToUInt16(bytes[29..(System.Index)(29 + 2)]),
                        System.BitConverter.ToUInt16(bytes[31..(System.Index)(31 + 2)]),
                        System.BitConverter.ToUInt16(bytes[33..(System.Index)(33 + 2)]),
                        System.BitConverter.ToUInt16(bytes[35..(System.Index)(35 + 2)])
                    };
                    Empire = bytes[37];
                }
            }

            """);
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using System.IO;
            using System.Threading.Tasks;
            using QuantumCore.Networking;

            // no async warning if no properties
            #pragma warning disable CS1998

            namespace QuantumCore.Core.Packets {
            
                public partial class CharacterInfo : IPacketSerializable
                {
                    public byte Header => 0x88;
                    public byte? SubHeader => null;
                    public bool HasStaticSize => true;
                    public bool HasSequence => false;
            
                    public void Serialize(byte[] bytes, in int offset = 0)
                    {
                        bytes[offset + 0] = 0x88;
                        bytes[offset + 1] = (System.Byte)(this.Vid >> 0);
                        bytes[offset + 2] = (System.Byte)(this.Vid >> 8);
                        bytes[offset + 3] = (System.Byte)(this.Vid >> 16);
                        bytes[offset + 4] = (System.Byte)(this.Vid >> 24);
                        bytes.WriteString(this.Name, offset + 5, (int)25);
                        bytes[offset + 30] = (System.Byte)(this.Parts[0] >> 0);
                        bytes[offset + 31] = (System.Byte)(this.Parts[0] >> 8);
                        bytes[offset + 32] = (System.Byte)(this.Parts[1] >> 0);
                        bytes[offset + 33] = (System.Byte)(this.Parts[1] >> 8);
                        bytes[offset + 34] = (System.Byte)(this.Parts[2] >> 0);
                        bytes[offset + 35] = (System.Byte)(this.Parts[2] >> 8);
                        bytes[offset + 36] = (System.Byte)(this.Parts[3] >> 0);
                        bytes[offset + 37] = (System.Byte)(this.Parts[3] >> 8);
                        bytes[offset + 38] = this.Empire;
                    }
            
                    public ushort GetSize()
                    {
                        return 39;
                    }
            
                    public static CharacterInfo Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
                    {
                        var __Vid = System.BitConverter.ToUInt32(bytes[(offset + 0)..(offset + 0 + 4)]);
                        var __Name = (bytes[(offset + 4)..(offset + 4 + 25)]).ReadNullTerminatedString();
                        var __Parts = new []
                        {
                            System.BitConverter.ToUInt16(bytes[(offset + 29)..(offset + 29 + 2)]),
                            System.BitConverter.ToUInt16(bytes[(offset + 31)..(offset + 31 + 2)]),
                            System.BitConverter.ToUInt16(bytes[(offset + 33)..(offset + 33 + 2)]),
                            System.BitConverter.ToUInt16(bytes[(offset + 35)..(offset + 35 + 2)])
                        };
                        var __Empire = bytes[(offset + 37)];
                        var obj = new QuantumCore.Core.Packets.CharacterInfo
                        {
                            Vid = __Vid,
                            Name = __Name,
                            Parts = __Parts,
                            Empire = __Empire
                        };
                        return obj;
                    }
            
                    public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
                        where T : IPacketSerializable
                    {
                        return (T)(object)Deserialize(bytes, offset);
                    }
            
                    public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
                    {
                        var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
                        try
                        {
                            var __Vid = await stream.ReadValueFromStreamAsync<UInt32>(buffer);
                            var __Name = await stream.ReadStringFromStreamAsync(buffer, (int)25);
                            var __Parts = new []
                            {
                                await stream.ReadValueFromStreamAsync<UInt16>(buffer),
                                await stream.ReadValueFromStreamAsync<UInt16>(buffer),
                                await stream.ReadValueFromStreamAsync<UInt16>(buffer),
                                await stream.ReadValueFromStreamAsync<UInt16>(buffer)
                            };
                            var __Empire = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                            var obj = new QuantumCore.Core.Packets.CharacterInfo
                            {
                                Vid = __Vid,
                                Name = __Name,
                                Parts = __Parts,
                                Empire = __Empire
                            };
                            return obj;
                        }
                        catch (Exception)
                        {
                            throw;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }
                }
            }
            """);
    }

    [Fact]
    public void Invalid_PositionDoesNotExist()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;

namespace QuantumCore.Auth.Packets
{
    [Packet(0x07, EDirection.Outgoing)]
    [PacketGenerator]
    public partial class LoginFailed
    {
        [Field(1, Length = 9)]
        public string Status { get; set; }
    }
}");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        driver.GetRunResult();
        diagnostics.Should().HaveCount(1);
        diagnostics[0].GetMessage().Should().Be("Field cannot have a higher number (1) than actual fields count 1");
    }

    [Fact]
    public void MultipleFiles()
    {
        const string file1 = """
                             using QuantumCore.Networking;

                             namespace QuantumCore.Game.Packets;

                             [ServerToClientPacket(0x20)]
                             public readonly ref partial struct Characters ()
                             {
                                 [FixedSizeArray(2)]
                                 public readonly Character[] CharacterList;
                             }
                             """;
        const string file2 = """
                             namespace QuantumCore.Game.Packets;

                             public readonly struct Character
                             {
                                 public readonly uint Id;
                             }
                             """;
        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());
        var inputCompilation = CreateCompilation(file1, file2);

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results.Should().HaveCount(1);
        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using QuantumCore.Networking;

            namespace QuantumCore.Game.Packets;

            [PacketData(StaticSize = 8)]
            public readonly ref partial struct Characters
            {
                public static implicit operator byte[] (Characters packet)
                {
                    var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                    packet.Serialize(bytes);
                    return bytes;
                }
            
                public void Serialize(Span<byte> bytes)
                {
                    bytes[0] = 0x20;
                    bytes[1] = (System.Byte)(this.CharacterList[0].Id >> 0);
                    bytes[2] = (System.Byte)(this.CharacterList[0].Id >> 8);
                    bytes[3] = (System.Byte)(this.CharacterList[0].Id >> 16);
                    bytes[4] = (System.Byte)(this.CharacterList[0].Id >> 24);
                    bytes[5] = (System.Byte)(this.CharacterList[1].Id >> 0);
                    bytes[6] = (System.Byte)(this.CharacterList[1].Id >> 8);
                    bytes[7] = (System.Byte)(this.CharacterList[1].Id >> 16);
                    bytes[8] = (System.Byte)(this.CharacterList[1].Id >> 24);
                }
            
                public ushort GetSize()
                {
                    return 9;
                }
            }

            """);
    }

    [Fact]
    public void TruncateNullBytes()
    {
        var inputCompilation = CreateCompilation(@"
using QuantumCore.Networking;
using System.ComponentModel.DataAnnotations;

namespace QuantumCore.Game.Packets;

[ClientToServerPacket(0x20)]
public partial record struct StringTest ()
{
    [FixedSizeString(25)]
    public string Name { get; set; }
};");

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo(@"/// <auto-generated/>
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using QuantumCore.Networking;

// no async warning if no properties
#pragma warning disable CS1998 

namespace QuantumCore.Game.Packets {

    public partial record struct StringTest : IPacketSerializable
    {
        public static byte Header => 0x20;
        public static byte? SubHeader => null;
        public static bool HasStaticSize => true;
        public static bool HasSequence => false;

        public void Serialize(byte[] bytes, in int offset = 0)
        {
            bytes[offset + 0] = 0x20;
            bytes.WriteString(this.Name, offset + 1, (int)25);
        }

        public ushort GetSize()
        {
            return 26;
        }

        public static StringTest Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
        {
            var __Name = (bytes[(offset + 0)..(offset + 0 + 25)]).ReadNullTerminatedString();
            var obj = new QuantumCore.Game.Packets.StringTest
            {
                Name = __Name
            };
            return obj;
        }

        public static T Deserialize<T>(ReadOnlySpan<byte> bytes, in int offset = 0)
            where T : IPacketSerializable
        {
            return (T)(object)Deserialize(bytes, offset);
        }

        public static async ValueTask<object> DeserializeFromStreamAsync(Stream stream)
        {
            var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
            try
            {
                var __Name = await stream.ReadStringFromStreamAsync(buffer, (int)25);
                var obj = new QuantumCore.Game.Packets.StringTest
                {
                    Name = __Name
                };
                return obj;
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }
    }
}");
    }

    [Fact]
    public void Deserialize_SubType()
    {
        var inputCompilation = CreateCompilation(
            """
            using QuantumCore.Networking;
            using System;

            namespace QuantumCore.Game.Packets;

            [ServerToClientPacket(0xD2)]
            public readonly ref partial struct ServerStatusPacket
            {
                public readonlyuint Size => (uint)Statuses.Length;
            
                
                public readonly ServerStatus[] Statuses;
            
                 public readonly byte IsSuccess;
            }

            public readonly ref ServerStatus
            {
                
                public readonly short Port;
                public readonly byte Status;
            }
            """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using System.IO;
            using System.Threading.Tasks;
            using QuantumCore.Networking;

            // no async warning if no properties
            #pragma warning disable CS1998

            namespace QuantumCore.Game.Packets {
            
                public partial class ServerStatusPacket : IPacketSerializable
                {
                    public byte Header => 0xD2;
                    public byte? SubHeader => null;
                    public bool HasStaticSize => false;
                    public bool HasSequence => false;
            
                    public void Serialize(byte[] bytes, in int offset = 0)
                    {
                        bytes[offset + 0] = 0xD2;
                        bytes[offset + 1] = (System.Byte)(this.GetSize() >> 0);
                        bytes[offset + 2] = (System.Byte)(this.GetSize() >> 8);
                        bytes[offset + 3] = (System.Byte)(this.GetSize() >> 16);
                        bytes[offset + 4] = (System.Byte)(this.GetSize() >> 24);
                        for (var i = 0; i < this.Statuses.Length; i++)
                        {
                            bytes[offset + 9 + i * 3] = (System.Byte)(this.Statuses[i].Port >> 0);
                            bytes[offset + 10 + i * 3] = (System.Byte)(this.Statuses[i].Port >> 8);
                            bytes[offset + 13 + i * 3] = this.Statuses[i].Status;
                        }
                        bytes[offset + 12 + this.Statuses.Length * 3] = this.IsSuccess;
                    }
            
                    public ushort GetSize()
                    {
                        return (ushort)(6 + this.Statuses.Length * 3);
                    }
            
                    public void Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
                    {
                        var __Size = System.BitConverter.ToUInt32(bytes[(System.Index)(offset + 0)..(System.Index)(offset + 0 + 4)]) - 9;
                        Statuses = new QuantumCore.Game.Packets.ServerStatus[__Size];
                        for (var i = 0; i < __Size; i++)
                        {
                            Statuses[i].Port = System.BitConverter.ToInt16(bytes[(System.Index)(offset + 4 + 3 * i)..(System.Index)(offset + 4 + 3 * i + 2)]);
                            Statuses[i].Status = bytes[(System.Index)(offset + 6 + 3 * i)];
                        }
                        IsSuccess = bytes[(System.Index)(offset + 7 + __Size)];
                    }
            
                    public async ValueTask DeserializeFromStreamAsync(Stream stream)
                    {
                        var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
                        try
                        {
                            var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 9;
                            Statuses = new QuantumCore.Game.Packets.ServerStatus[__Size];
                            for (var i = 0; i < __Size; i++)
                            {
                                Statuses[i].Port = await stream.ReadValueFromStreamAsync<Int16>(buffer);
                                Statuses[i].Status = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                            }
                            IsSuccess = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                        }
                        catch (Exception)
                        {
                            throw;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }
                }
            }
            """);
    }

    [Fact]
    public void Sequence()
    {
        var inputCompilation = CreateCompilation(
            """
            using QuantumCore.Networking;

            namespace QuantumCore.Game.Packets;

            [ClientToServerPacket(0x02, HasSequence = true)]

            public readonly ref partial struct Attack
            {
                
                public byte AttackType ;
                public uint Vid ;
                [FixedSizeArray( 2)]
                public byte[] Unknown ;
            }
            """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using System.IO;
            using System.Threading.Tasks;
            using QuantumCore.Networking;

            // no async warning if no properties
            #pragma warning disable CS1998

            namespace QuantumCore.Game.Packets {
            
                public partial class ServerStatusPacket : IPacketSerializable
                {
                    public byte Header => 0xD2;
                    public byte? SubHeader => null;
                    public bool HasStaticSize => false;
                    public bool HasSequence => false;
            
                    public void Serialize(byte[] bytes, in int offset = 0)
                    {
                        bytes[offset + 0] = 0xD2;
                        bytes[offset + 1] = (System.Byte)(this.GetSize() >> 0);
                        bytes[offset + 2] = (System.Byte)(this.GetSize() >> 8);
                        bytes[offset + 3] = (System.Byte)(this.GetSize() >> 16);
                        bytes[offset + 4] = (System.Byte)(this.GetSize() >> 24);
                        for (var i = 0; i < this.Statuses.Length; i++)
                        {
                            bytes[offset + 9 + i * 3] = (System.Byte)(this.Statuses[i].Port >> 0);
                            bytes[offset + 10 + i * 3] = (System.Byte)(this.Statuses[i].Port >> 8);
                            bytes[offset + 13 + i * 3] = this.Statuses[i].Status;
                        }
                        bytes[offset + 12 + this.Statuses.Length * 3] = this.IsSuccess;
                    }
            
                    public ushort GetSize()
                    {
                        return (ushort)(6 + this.Statuses.Length * 3);
                    }
            
                    public void Deserialize(ReadOnlySpan<byte> bytes, in int offset = 0)
                    {
                        var __Size = System.BitConverter.ToUInt32(bytes[(System.Index)(offset + 0)..(System.Index)(offset + 0 + 4)]) - 9;
                        Statuses = new QuantumCore.Game.Packets.ServerStatus[__Size];
                        for (var i = 0; i < __Size; i++)
                        {
                            Statuses[i].Port = System.BitConverter.ToInt16(bytes[(System.Index)(offset + 4 + 3 * i)..(System.Index)(offset + 4 + 3 * i + 2)]);
                            Statuses[i].Status = bytes[(System.Index)(offset + 6 + 3 * i)];
                        }
                        IsSuccess = bytes[(System.Index)(offset + 7 + __Size)];
                    }
            
                    public async ValueTask DeserializeFromStreamAsync(Stream stream)
                    {
                        var buffer = ArrayPool<byte>.Shared.Rent(NetworkingConstants.BufferSize);
                        try
                        {
                            var __Size = await stream.ReadValueFromStreamAsync<UInt32>(buffer) - 9;
                            Statuses = new QuantumCore.Game.Packets.ServerStatus[__Size];
                            for (var i = 0; i < __Size; i++)
                            {
                                Statuses[i].Port = await stream.ReadValueFromStreamAsync<Int16>(buffer);
                                Statuses[i].Status = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                            }
                            IsSuccess = await stream.ReadValueFromStreamAsync<Byte>(buffer);
                        }
                        catch (Exception)
                        {
                            throw;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }
                }
            }
            """);
    }

    [Fact]
    public void ReadonlyRefStruct_ClientToServer()
    {
        var inputCompilation = CreateCompilation(
            """
            using QuantumCore.Networking;

            namespace QuantumCore.Game.Packets;

            [ClientToServerPacket(0xff)]
            public readonly ref partial struct GCHandshake
            {
                public readonly uint Handshake;
                public readonly uint Time;
                public readonly uint Delta;
            }

            public class GCHandshakeHandler
            {
                public void Execute(GCHandshake packet) {
            
                }
            }
            """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ClientToServerPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using QuantumCore.Networking;

            namespace QuantumCore.Game.Packets;

            [PacketData(StaticSize = 12)]
            public readonly ref partial struct GCHandshake
            {
                public GCHandshake(ReadOnlySpan<byte> bytes)
                {
                    Handshake = System.BitConverter.ToUInt32(bytes[0..(System.Index)(0 + 4)]);
                    Time = System.BitConverter.ToUInt32(bytes[4..(System.Index)(4 + 4)]);
                    Delta = System.BitConverter.ToUInt32(bytes[8..(System.Index)(8 + 4)]);
                }
            }

            """);
    }

    [Fact]
    public void ReadonlyRefStruct_ServerToClient()
    {
        var inputCompilation = CreateCompilation(
            """
            using QuantumCore.Networking;

            namespace QuantumCore.Game.Packets;

            [ServerToClientPacket(0xff)]
            public readonly ref partial struct GCHandshake
            {
                public readonly uint Handshake;
                public readonly uint Time;
                public readonly uint Delta;
            }
            """);

        GeneratorDriver driver = CSharpGeneratorDriver.Create(new ServerToClientPacketGenerator());

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);

        var runResult = driver.GetRunResult();
        diagnostics.Should().BeEmpty();
        outputCompilation.GetDiagnostics().Should().BeEmpty();

        runResult.GeneratedTrees.Should().HaveCount(1);
        runResult.Diagnostics.Should().BeEmpty();

        runResult.Results[0].GeneratedSources.Should().HaveCount(1);
        runResult.Results[0].Diagnostics.Should().BeEmpty();
        runResult.Results[0].Exception.Should().BeNull();
        runResult.Results[0].GeneratedSources[0].SourceText.ToString().Should().BeEquivalentTo("""
            /// <auto-generated/>
            using System;
            using System.Buffers;
            using QuantumCore.Networking;

            namespace QuantumCore.Game.Packets;

            [PacketData(StaticSize = 12)]
            public readonly ref partial struct GCHandshake
            {
                public static implicit operator byte[] (GCHandshake packet)
                {
                    var bytes = ArrayPool<byte>.Shared.Rent(packet.GetSize());
                    packet.Serialize(bytes);
                    return bytes;
                }
            
                public void Serialize(Span<byte> bytes)
                {
                    bytes[0] = 0xFF;
                    bytes[1] = (System.Byte)(this.Handshake >> 0);
                    bytes[2] = (System.Byte)(this.Handshake >> 8);
                    bytes[3] = (System.Byte)(this.Handshake >> 16);
                    bytes[4] = (System.Byte)(this.Handshake >> 24);
                    bytes[5] = (System.Byte)(this.Time >> 0);
                    bytes[6] = (System.Byte)(this.Time >> 8);
                    bytes[7] = (System.Byte)(this.Time >> 16);
                    bytes[8] = (System.Byte)(this.Time >> 24);
                    bytes[9] = (System.Byte)(this.Delta >> 0);
                    bytes[10] = (System.Byte)(this.Delta >> 8);
                    bytes[11] = (System.Byte)(this.Delta >> 16);
                    bytes[12] = (System.Byte)(this.Delta >> 24);
                }
            
                public ushort GetSize()
                {
                    return 13;
                }
            }

            """);
    }
}